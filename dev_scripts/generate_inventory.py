#!/usr/bin/env python3
"""Small, robust inventory generator — functions are dotfile-exclusive.

This script writes docs/inventory.md and intentionally considers functions only
from assets/.functions so interactive helpers remain dotfile-owned.
"""
from pathlib import Path
import re

ROOT = Path(__file__).resolve().parents[1]
ASSETS = ROOT / "assets"
SCRIPTS = ROOT / "scripts"
DOCS = ROOT / "docs"
DOCS.mkdir(exist_ok=True)


def parse_aliases(path: Path):
    if not path.exists():
        return []
    out = []
    for line in path.read_text().splitlines():
        if not line.strip() or line.strip().startswith("#"):
            continue
        left, _, comment = line.partition("#")
        left = left.strip()
        if not left.startswith("alias"):
            continue
        try:
            _, rest = left.split(None, 1)
        except ValueError:
            continue
        name = rest.split("=", 1)[0].strip().strip('"').strip("'")
        out.append((name, comment.strip()))
    return out


def parse_functions(path: Path):
    if not path.exists():
        return []
    res = []
    lines = path.read_text().splitlines()
    for i, ln in enumerate(lines):
        # Match explicit function declarations only. Avoid false positives
        # from control-flow keywords such as `if (...)` or `while (...)`.
        m = re.match(r"^\s*function\s+([a-zA-Z0-9_]+)\s*\(", ln)
        if m:
            name = m.group(1)
        else:
            m2 = re.match(r"^\s*([a-zA-Z0-9_]+)\s*\(\)\s*\{", ln)
            if m2:
                name = m2.group(1)
            else:
                continue
        desc_lines = []
        j = i - 1
        while j >= 0 and lines[j].strip().startswith("#"):
            desc_lines.insert(0, lines[j].strip().lstrip("#").strip())
            j -= 1
        res.append((name, " ".join(desc_lines).strip()))
    return res


def main():
    aliases = [(n.lower(), d) for (n, d) in parse_aliases(ASSETS / ".aliases")]
    functions = sorted(
        [(n.lower(), d) for (n, d) in parse_functions(ASSETS / ".functions")]
    )

    completions_dir = ASSETS / "completions"
    completions = []
    if completions_dir.exists():
        completions = sorted(
            [
                p.name.lstrip("_")
                for p in completions_dir.iterdir()
                if p.is_file() and p.name.startswith("_")
            ]
        )

    installs = []
    rx = re.compile(r'print_install\s+"([^"]+)"')
    for f in SCRIPTS.glob("*.sh"):
        for ln in f.read_text().splitlines():
            m = rx.search(ln)
            if m:
                installs.append((f.name, m.group(1).lower()))

    defaults = set()
    rx2 = re.compile(
        r"set_(?:user_)?default\s+(\S+)\s+(?:\"([^\"]+)\"|\'([^']+)\'|(\S+))"
    )
    for f in SCRIPTS.glob("*.sh"):
        for ln in f.read_text().splitlines():
            if ln.strip().startswith("#"):
                continue
            m = rx2.search(ln)
            if m:
                key = m.group(2) or m.group(3) or m.group(4)
                if key:
                    defaults.add((m.group(1).lower(), key.lower()))

    out = DOCS / "inventory.md"
    with out.open("w") as fh:
        fh.write("# MachInit Inventory\n\n")
        fh.write("Generated by dev_scripts/generate_inventory.py\n\n")

        fh.write("## Aliases (assets/.aliases)\n")
        if aliases:
            for n, d in aliases:
                fh.write(f"- `{n}`" + (f" — {d}" if d else "") + "\n")
        else:
            fh.write("- (none)\n")

        fh.write("\n## Functions (assets/.functions — dotfile-only)\n")
        if functions:
            for n, d in functions:
                fh.write(f"- `{n}()`" + (f" — {d}" if d else "") + "\n")
        else:
            fh.write("- (none)\n")

        fh.write("\n## Completions (assets/completions)\n")
        if completions:
            for c in completions:
                fh.write(f"- `{c}`\n")
        else:
            fh.write("- (none)\n")

        fh.write("\n## App/install targets (detected via print_install in scripts/)\n")
        if installs:
            for s, a in installs:
                fh.write(f"- `{a}` (from `{s}`)\n")
        else:
            fh.write("- (none)\n")

        fh.write("\n## Defaults referenced (set_default / set_user_default)\n")
        if defaults:
            for d, k in sorted(defaults):
                fh.write(f"- `{d}` `{k}`\n")
        else:
            fh.write("- (none)\n")

        fh.write("\n---\n")
        fh.write(f"- Aliases: {len(aliases)}\n")
        fh.write(f"- Functions: {len(functions)}\n")
        fh.write(f"- Completions: {len(completions)}\n")
        fh.write(f"- Install targets found: {len(installs)}\n")
        fh.write(f"- Default entries found: {len(defaults)}\n")

    print("WROTE:", out)


if __name__ == "__main__":
    main()
