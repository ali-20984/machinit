alias bup="brew update && brew upgrade && brew cleanup"
alias shrug="echo '¯\_(ツ)_/¯' | pbcopy"
## Robust ll: prefer GNU 'ls' from Homebrew (gnubin path) or 'gls' if present,
## otherwise fall back to system 'ls'. This avoids hard failures when coreutils
## is not installed in the Homebrew prefix used during development.
ll() {
	# Accept arbitrary args
	if command -v gls >/dev/null 2>&1; then
		gls -AhlFo --color --group-directories-first "$@"
	elif ls --color >/dev/null 2>&1; then
		# system ls supports --color (likely GNU), use colorized listing
		ls -AhlFo --color --group-directories-first "$@" 2>/dev/null || ls -AhlFo "$@"
	elif command -v gls >/dev/null 2>&1; then
		gls -AhlFo --color --group-directories-first "$@"
	elif command -v ls >/dev/null 2>&1; then
		# BSD ls lacks --color; don't pass unknown options
		ls -AhlFo --group-directories-first "$@" 2>/dev/null || ls -AhlFo "$@"
	else
		/bin/ls -AhlF "$@"
	fi
}
alias reloaddns="dscacheutil -flushcache && sudo killall -HUP mDNSResponder"
alias dnsreload="dscacheutil -flushcache && sudo killall -HUP mDNSResponder"
alias timestamp="date +%s"
alias jsrefresh="rm -rf node_modules/ package-lock.json && npm install"

# Navigation
alias ..="cd .."
alias ...="cd ../../.."
alias ....="cd ../../../../"
alias .....="cd ../../../../"
alias cd..="cd .."
alias ~="cd ~"
alias -- -="cd -"

# Shortcuts
alias c="clear"
alias h="history"
alias o="open ."

# Quick zsh editing
alias zshconf="nano ~/.zshrc"

# Project navigation shortcuts
alias projects="cd ~/Projects"
alias repos="cd ~/Projects"  # same as projects (Projects lives in ~/Projects -> often symlink to ~/Documents/Projects)

# Quick find wrapper (name search)
alias qfind='find . -name'

# Sockets: requires sudo
alias lsock='sudo lsof -i -P'

# Network
alias ping_test="ping 1.1.1.1"

# myip: robust public IPv4 lookup using multiple public endpoints (tries each in order)
myip() {
	# Usage: myip [--service <url>] [--ipv6|-6]
	# Default: use Amazon checkip (https://checkip.amazonaws.com) first, then fallbacks
	local service=""
	local prefer_v6=false

	while [ $# -gt 0 ]; do
		case "$1" in
			--service)
				shift
				service="$1"
				shift
				;;
			--ipv6|-6)
				prefer_v6=true
				shift
				;;
			--help|-h)
				echo "Usage: myip [--service <url|name>] [--ipv6|-6]";
				echo "Named services: aws, icanhazip, ifconfig, ident, ipinfo";
				echo "Examples:";
				echo "  myip                  # default (AWS checkip)";
				echo "  myip --service aws    # use named aws service (checkip.amazonaws.com)";
				echo "  myip --ipv6           # prefer IPv6 lookups";
				return 0
				;;
			*)
				# allow single positional to be treated as service url/name
				if [ -z "$service" ]; then
					service="$1"
				fi
				shift
				;;
		esac
	done

	# Support named shorthands and a prioritized list of endpoints. If --service
	# provided, try that first (the service may be a name like 'aws' or a full URL).
	declare -A SERVICE_MAP
	SERVICE_MAP[aws]="https://checkip.amazonaws.com"
	SERVICE_MAP[icanhazip]="https://icanhazip.com"
	SERVICE_MAP[ican]="https://icanhazip.com"
	SERVICE_MAP[ifconfig]="https://ifconfig.me"
	SERVICE_MAP[ident]="https://ident.me"
	SERVICE_MAP[ipinfo]="https://ipinfo.io/ip"

	# If the caller provided a named service, translate to URL.
	if [ -n "$service" ] && [[ "${SERVICE_MAP[$service]+_}" ]]; then
		service="${SERVICE_MAP[$service]}"
	fi

	# Add a couple more small endpoints which generally return only the IP in plaintext
	local services=("https://checkip.amazonaws.com" "https://icanhazip.com" "https://ifconfig.me" "https://ident.me" "https://ipinfo.io/ip" "https://api.ipify.org" "https://ifconfig.co/ip")
	if [ -n "$service" ]; then
		services=("$service" "https://checkip.amazonaws.com" "https://icanhazip.com" "https://ifconfig.me" "https://ident.me" "https://ipinfo.io/ip")
	fi

	local curl_opts="-s --max-time 3"
	if [ "$prefer_v6" = true ]; then
		curl_opts="$curl_opts -6"
	else
		curl_opts="$curl_opts -4"
	fi

	# helper: check whether a string looks like an IPv4 or IPv6 address
	looks_like_ipv4() {
		[[ "$1" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$ ]]
	}

	looks_like_ipv6() {
		[[ "$1" == *":"* ]] && [[ "$1" =~ ^[0-9a-fA-F:\.]+$ ]]
	}

	extract_ip() {
		local text="$1"
		local ip=""

		# Try JSON-style: "ip": "1.2.3.4" (common for some APIs)
		ip=$(printf "%s" "$text" | grep -Eo '"ip"[[:space:]]*:[[:space:]]*"[^"]+"' | sed -E 's/.*"ip"[[:space:]]*:[[:space:]]*"([^"]+)".*/\1/' | head -n1 || true)
		if [ -n "$ip" ]; then
			printf "%s" "$ip" && return 0
		fi

		# Try strict IPv4 (0-255 per octet)
		ip=$(printf "%s" "$text" | grep -Eo '((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])' | head -n1 || true)
		if [ -n "$ip" ]; then
			printf "%s" "$ip" && return 0
		fi

		# Try IPv6-ish tokens (relaxed matching, capture common patterns)
		ip=$(printf "%s" "$text" | grep -Eo '([0-9a-fA-F]{1,4}:){1,7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F:]+::[0-9a-fA-F:]*)' | head -n1 || true)
		if [ -n "$ip" ]; then
			printf "%s" "$ip" && return 0
		fi

		# Fallback: any token that looks like an IPv4-ish pattern (more permissive)
		ip=$(printf "%s" "$text" | grep -Eo '([0-9]{1,3}\.){3}[0-9]{1,3}' | head -n1 || true)
		if [ -n "$ip" ]; then
			printf "%s" "$ip" && return 0
		fi

		return 1
	}

	for s in "${services[@]}"; do
		if command -v curl >/dev/null 2>&1; then
			# use a short user-agent and fail fast on HTTP errors
			out=$(curl $curl_opts -A "machinit/myip" --retry 1 --retry-connrefused --retry-delay 1 "$s" 2>/dev/null || true)
		elif command -v wget >/dev/null 2>&1; then
			if [ "$prefer_v6" = true ]; then
				out=$(wget -qO- --timeout=3 -6 "$s" 2>/dev/null || true)
			else
				out=$(wget -qO- --timeout=3 "$s" 2>/dev/null || true)
			fi
		else
			echo "No HTTP client (curl|wget) found to fetch public IP"
			return 1
		fi

		# Normalize whitespace/newlines and try to extract an IP-looking value
		out=$(echo "$out" | tr -d '\r' || true)
		# Try to extract a visible IP address from the output
		ip=""
		ip=$(extract_ip "$out" || true)
		if [ -n "$ip" ]; then
			echo "$ip"
			return 0
		fi
	done

	# Try DNS-based fallback (OpenDNS resolver) — often reliable in restricted
	# environments where HTTP endpoints are blocked or return HTML.
	if command -v dig >/dev/null 2>&1; then
		if [ "$prefer_v6" = true ]; then
			dns_out=$(dig -6 +short myip.opendns.com @resolver1.opendns.com 2>/dev/null || true)
		else
			dns_out=$(dig +short myip.opendns.com @resolver1.opendns.com 2>/dev/null || true)
		fi
		dns_out=$(echo "$dns_out" | tr -d '\r' | tr -d '\n' || true)
		if [ -n "$dns_out" ] && extract_ip "$dns_out" >/dev/null 2>&1; then
			echo "$dns_out"
			return 0
		fi
	fi

	echo "Could not determine public IP from known services"
	return 1
}
alias localip="ipconfig getifaddr en0"

# npm short install alias
alias ni="npm install"
 

# System
alias path='echo -e ${PATH//:/\\n}'
alias cpu='top -o cpu'
alias mem='top -o rsize'

# Lock the screen (when going AFK)
alias afk='pmset displaysleepnow'

# Find WiFi password, add the name:
alias wifi_pass='security find-generic-password -wa'
