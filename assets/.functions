#!/usr/bin/env bash

# Create a new directory and enter it
function mkd() {
	mkdir -p "$@" && cd "$_";
}

# Change working directory to the top-most Finder window location
function cdf() { # short for `cdfinder`
	cd "$(osascript -e 'tell app "Finder" to POSIX path of (insertion location as alias)')";
}

# Create a .tar.gz archive, using `zopfli`, `pigz` or `gzip` for compression
function targz() {
	local tmpFile="${@%/}.tar";
	tar -cvf "${tmpFile}" --exclude=".DS_Store" "${@}" || return 1;

	size=$(
		stat -f"%z" "${tmpFile}" 2> /dev/null; # macOS `stat`
		stat -c"%s" "${tmpFile}" 2> /dev/null;  # GNU `stat`
	);

	local cmd="";
	if (( size < 52428800 )) && hash zopfli 2> /dev/null; then
		# the .tar file is smaller than 50 MB and Zopfli is available; use it
		cmd="zopfli";
	else
		if hash pigz 2> /dev/null; then
			cmd="pigz";
		else
			cmd="gzip";
		fi;
	fi;

	echo "Compressing .tar ($((size / 1000)) kB) using \`${cmd}\`…";
	"${cmd}" -v "${tmpFile}" || return 1;
	[ -f "${tmpFile}" ] && rm "${tmpFile}";

	zippedSize=$(
		stat -f"%z" "${tmpFile}.gz" 2> /dev/null; # macOS `stat`
		stat -c"%s" "${tmpFile}.gz" 2> /dev/null; # GNU `stat`
	);

	echo "${tmpFile}.gz ($((zippedSize / 1000)) kB) created successfully.";
}

# Determine size of a file or total size of a directory
function fs() {
	if du -b /dev/null > /dev/null 2>&1; then
		local arg=-sbh;
	else
		local arg=-sh;
	fi
	if [[ -n "$@" ]]; then
		du $arg -- "$@";
	else
		du $arg .[^.]* ./*;
	fi;
}

# Use Git’s colored diff when available
hash git &>/dev/null;
if [ $? -eq 0 ]; then
	function diff() {
		git diff --no-index --color-words "$@";
	}
fi;

# Create a data URL from a file
function dataurl() {
	local mimeType=$(file -b --mime-type "$1");
	if [[ $mimeType == text/* ]]; then
		mimeType="${mimeType};charset=utf-8";
	fi
	echo "data:${mimeType};base64,$(openssl base64 -in "$1" | tr -d '\n')";
}

# Start an HTTP server from a directory, optionally specifying the port
function server() {
	local port="${1:-8000}";
	sleep 1 && open "http://localhost:${port}/" &
	# Set the default Content-Type to `text/plain` instead of `application/octet-stream`
	# And serve everything as UTF-8 (although not technically correct, this doesn’t break anything for binary files)
	python3 -c $'import http.server; import sys;
class CORSRequestHandler(http.server.SimpleHTTPRequestHandler):
    def end_headers(self):
        self.send_header("Access-Control-Allow-Origin", "*")
        http.server.SimpleHTTPRequestHandler.end_headers(self)
if __name__ == "__main__":
    port = int(sys.argv[1]) if len(sys.argv) > 1 else 8000
    server = http.server.HTTPServer(("", port), CORSRequestHandler)
    server.serve_forever()' "$port";
}

# Compare original and gzipped file size
function gz() {
	local origsize=$(wc -c < "$1");
	local gzipsize=$(gzip -c "$1" | wc -c);
	local ratio=$(echo "$gzipsize * 100 / $origsize" | bc -l);
	printf "orig: %d bytes\n" "$origsize";
	printf "gzip: %d bytes (%2.2f%%)\n" "$gzipsize" "$ratio";
}

# Run `dig` and display the most useful info
function digga() {
	dig +nocmd "$1" any +multiline +noall +answer;
}

# Show all the names (CNs and SANs) listed in the SSL certificate
# for a given domain
function getcertnames() {
	if [ -z "${1}" ]; then
		echo "ERROR: No domain specified.";
		return 1;
	fi;

	local domain="${1}";
	echo "Testing ${domain}…";
	echo ""; # newline

	local tmp=$(echo -e "GET / HTTP/1.0\nEOT" \
		| openssl s_client -connect "${domain}:443" -servername "${domain}" 2>&1);

	if [[ "${tmp}" = *"-----BEGIN CERTIFICATE-----"* ]]; then
		local certText=$(echo "${tmp}" \
			| openssl x509 -text -certopt "no_aux, no_header, no_issuer, no_pubkey, \
			no_serial, no_sigdump, no_signame, no_validity, no_version");
		echo "Common Name:";
		echo ""; # newline
		echo "${certText}" | grep "Subject:" | sed -e "s/^.*CN=//" | sed -e "s/\/emailAddress=.*//";
		echo ""; # newline
		echo "Subject Alternative Name(s):";
		echo ""; # newline
		echo "${certText}" | grep -A 1 "Subject Alternative Name:" \
			| sed -e "2s/DNS://g" -e "s/ //g" | tr "," "\n" | tail -n +2;
		return 0;
	else
		echo "ERROR: Certificate not found.";
		return 1;
	fi;
}

# `o` with no arguments opens the current directory, otherwise opens the given
# location
function o() {
	if [ $# -eq 0 ]; then
		open .;
	else
		open "$@";
	fi;
}

# `tre` is a shorthand for `tree` with hidden files and color enabled, ignoring
# the `.git` directory, listing directories first. The output gets piped into
# `less` with options to preserve color and line numbers, unless the output is
# small enough for one screen.
function tre() {
	tree -aC -I '.git|node_modules|bower_components' --dirsfirst "$@" | less -FRNX;
}

# Generate a new SSH key for GitHub
function generate_git_key() {
    if [ -z "$1" ]; then
        echo "Usage: generate_git_key <email>"
        return 1
    fi

    echo "Generating a new SSH key for GitHub..."

    # Generating a new SSH key
    ssh-keygen -t ed25519 -C "$1" -f ~/.ssh/id_ed25519

    # Adding your SSH key to the ssh-agent
    eval "$(ssh-agent -s)"

    if [ ! -f ~/.ssh/config ]; then
        touch ~/.ssh/config
    fi

    # Check if config already exists to avoid duplication
    if ! grep -q "IdentityFile ~/.ssh/id_ed25519" ~/.ssh/config; then
        echo -e "Host *\n AddKeysToAgent yes\n UseKeychain yes\n IdentityFile ~/.ssh/id_ed25519" >> ~/.ssh/config
    fi

    # Add key to agent (using --apple-use-keychain if available, else -K for older macOS)
    if ssh-add --help 2>&1 | grep -q -- "--apple-use-keychain"; then
        ssh-add --apple-use-keychain ~/.ssh/id_ed25519
    else
        ssh-add -K ~/.ssh/id_ed25519
    fi

    # Adding your SSH key to your GitHub account
    echo "run 'pbcopy < ~/.ssh/id_ed25519.pub' and paste that into GitHub"
}

## findPid: find out the pid of a specified process
## -----------------------------------------------------
## Note that the command name can be specified via a regex
## E.g. findPid '/d$/' finds pids of all processes with names ending in 'd'
## Without the 'sudo' it will only find processes of the current user
## -----------------------------------------------------
findPid () { lsof -t -c "$@" ; }

# lsock is defined in .aliases intentionally to keep aliases centralized

# recent: cd to the most recently modified project directory under ~/Projects
recent() {
	# Support a few useful invocation modes:
	#  - recent            -> cd to most recently modified project
	#  - recent 2          -> cd to the 2nd most recent project
	#  - recent -n 3       -> cd to the 3rd most recent project
	#  - recent myproj     -> cd to the first project whose name contains 'myproj' (case-sensitive)

	local candidates=()
	local roots=("$HOME/Projects" "$HOME/Documents/Projects")

	for r in "${roots[@]}"; do
		if [ -d "$r" ]; then
			while IFS= read -r -d '' d; do
				# skip the root itself
				[ "$d" = "$r" ] && continue
				candidates+=("$d")
			done < <(find "$r" -maxdepth 1 -type d -print0 2>/dev/null)
		fi
	done

	if [ ${#candidates[@]} -eq 0 ]; then
		echo "No project directories found in ${roots[*]}"
		return 1
	fi

	# sort by mtime (newest first)
	IFS=$'\n' sorted=( $(for d in "${candidates[@]}"; do printf '%s\t%s\n' "$(stat -f%mt "$d")" "$d"; done | sort -r -n | awk -F"\t" '{ print $2 }') )

	# No args -> go to most recent
	if [ $# -eq 0 ]; then
		# Use a portable selection for the first element (works in bash and zsh)
		target=$(printf '%s\n' "${sorted[@]}" | sed -n '1p')
		if [ -z "${target}" ]; then
			echo "No project directory found.";
			return 1;
		fi
		cd "${target}" || return 1
		return 0
	fi

	# Numeric argument (1-based index)
	if [[ "$1" =~ ^[0-9]+$ ]]; then
		idx=$(( $1 - 1 ))
		# select the (idx+1)th element in a portable way
		target=$(printf '%s\n' "${sorted[@]}" | sed -n "$((idx + 1))p")
		if [ -n "${target}" ]; then
			cd "${target}" || return 1
			return 0
		else
			echo "Index out of range: $1"
			return 1
		fi
	fi

	# -n N form
	if [ "$1" = "-n" ] && [[ "$2" =~ ^[0-9]+$ ]]; then
		idx=$(( $2 - 1 ))
		# select the (idx+1)th element in a portable way
		target=$(printf '%s\n' "${sorted[@]}" | sed -n "$((idx + 1))p")
		if [ -n "${target}" ]; then
			cd "${target}" || return 1
			return 0
		else
			echo "Index out of range: $2"
			return 1
		fi
	fi

	# Otherwise treat all args as a pattern and match by directory name
	local pattern="$*"
	for d in "${sorted[@]}"; do
		name=$(basename "$d")
		if [[ "$name" == *"$pattern"* ]]; then
			cd "$d" || return 1
			return 0
		fi
	done

	echo "No matching project found for '$pattern'"
	return 1
}

# ll: robust listing — prefer GNU 'ls' if available, otherwise fallback
ll() {
	# Accept arbitrary args
	if command -v gls >/dev/null 2>&1; then
		gls -AhlFo --color --group-directories-first "$@"
	elif ls --color >/dev/null 2>&1; then
		# system ls supports --color (likely GNU), use colorized listing
		ls -AhlFo --color --group-directories-first "$@" 2>/dev/null || ls -AhlFo "$@"
	elif command -v gls >/dev/null 2>&1; then
		gls -AhlFo --color --group-directories-first "$@"
	elif command -v ls >/dev/null 2>&1; then
		# BSD ls lacks --color; don't pass unknown options
		ls -AhlFo --group-directories-first "$@" 2>/dev/null || ls -AhlFo "$@"
	else
		/bin/ls -AhlF "$@"
	fi
}

# myip: robust public IP lookup (moved from assets/.aliases)
myip() {
	# Usage: myip [--service <url>] [--ipv6|-6]
	# Default: use Amazon checkip (https://checkip.amazonaws.com) first, then fallbacks
	local service=""
	local prefer_v6=false

	while [ $# -gt 0 ]; do
		case "$1" in
			--service)
				shift
				service="$1"
				shift
				;;
			--ipv6|-6)
				prefer_v6=true
				shift
				;;
			--help|-h)
				echo "Usage: myip [--service <url|name>] [--ipv6|-6]";
				echo "Named services: aws, icanhazip, ifconfig, ident, ipinfo";
				echo "Examples:";
				echo "  myip                  # default (AWS checkip)";
				echo "  myip --service aws    # use named aws service (checkip.amazonaws.com)";
				echo "  myip --ipv6           # prefer IPv6 lookups";
				return 0
				;;
			*)
				# allow single positional to be treated as service url/name
				if [ -z "$service" ]; then
					service="$1"
				fi
				shift
				;;
		esac
	done

	declare -A SERVICE_MAP
	SERVICE_MAP[aws]="https://checkip.amazonaws.com"
	SERVICE_MAP[icanhazip]="https://icanhazip.com"
	SERVICE_MAP[ican]="https://icanhazip.com"
	SERVICE_MAP[ifconfig]="https://ifconfig.me"
	SERVICE_MAP[ident]="https://ident.me"
	SERVICE_MAP[ipinfo]="https://ipinfo.io/ip"

	if [ -n "$service" ] && [[ "${SERVICE_MAP[$service]+_}" ]]; then
		service="${SERVICE_MAP[$service]}"
	fi

	local services=("https://checkip.amazonaws.com" "https://icanhazip.com" "https://ifconfig.me" "https://ident.me" "https://ipinfo.io/ip" "https://api.ipify.org" "https://ifconfig.co/ip")
	if [ -n "$service" ]; then
		services=("$service" "https://checkip.amazonaws.com" "https://icanhazip.com" "https://ifconfig.me" "https://ident.me" "https://ipinfo.io/ip")
	fi

	local curl_opts="-s --max-time 3"
	if [ "$prefer_v6" = true ]; then
		curl_opts="$curl_opts -6"
	else
		curl_opts="$curl_opts -4"
	fi

	extract_ip() {
		local text="$1"
		local ip=""

		ip=$(printf "%s" "$text" | grep -Eo '"ip"[[:space:]]*:[[:space:]]*"[^"]+"' | sed -E 's/.*"ip"[[:space:]]*:[[:space:]]*"([^"]+)".*/\1/' | head -n1 || true)
		if [ -n "$ip" ]; then
			printf "%s" "$ip" && return 0
		fi

		ip=$(printf "%s" "$text" | grep -Eo '((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])' | head -n1 || true)
		if [ -n "$ip" ]; then
			printf "%s" "$ip" && return 0
		fi

		ip=$(printf "%s" "$text" | grep -Eo '([0-9a-fA-F]{1,4}:){1,7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F:]+::[0-9a-fA-F:]*)' | head -n1 || true)
		if [ -n "$ip" ]; then
			printf "%s" "$ip" && return 0
		fi

		ip=$(printf "%s" "$text" | grep -Eo '([0-9]{1,3}\.){3}[0-9]{1,3}' | head -n1 || true)
		if [ -n "$ip" ]; then
			printf "%s" "$ip" && return 0
		fi

		return 1
	}

	for s in "${services[@]}"; do
		if command -v curl >/dev/null 2>&1; then
			out=$(curl $curl_opts -A "machinit/myip" --retry 1 --retry-connrefused --retry-delay 1 "$s" 2>/dev/null || true)
		elif command -v wget >/dev/null 2>&1; then
			if [ "$prefer_v6" = true ]; then
				out=$(wget -qO- --timeout=3 -6 "$s" 2>/dev/null || true)
			else
				out=$(wget -qO- --timeout=3 "$s" 2>/dev/null || true)
			fi
		else
			echo "No HTTP client (curl|wget) found to fetch public IP"
			return 1
		fi

		out=$(echo "$out" | tr -d '\r' || true)
		ip=""
		ip=$(extract_ip "$out" || true)
		if [ -n "$ip" ]; then
			echo "$ip"
			return 0
		fi
	done

	if command -v dig >/dev/null 2>&1; then
		if [ "$prefer_v6" = true ]; then
			dns_out=$(dig -6 +short myip.opendns.com @resolver1.opendns.com 2>/dev/null || true)
		else
			dns_out=$(dig +short myip.opendns.com @resolver1.opendns.com 2>/dev/null || true)
		fi
		dns_out=$(echo "$dns_out" | tr -d '\r' | tr -d '\n' || true)
		if [ -n "$dns_out" ] && extract_ip "$dns_out" >/dev/null 2>&1; then
			echo "$dns_out"
			return 0
		fi
	fi

	echo "Could not determine public IP from known services"
	return 1
}
